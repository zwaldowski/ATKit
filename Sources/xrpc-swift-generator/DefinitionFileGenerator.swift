import Foundation
import RegexBuilder
import SwiftSyntax
import SwiftSyntaxBuilder

struct DefinitionFileGenerator {

    enum Failure: Error {
        case referenceNotFound(String)
    }

    var lexicon: Lexicon
    var visibility: Visibility
    var lexiconsByID = [String: Lexicon]()
    var moduleName: String

    func generateSourceFile() throws -> SourceFileSyntax {
        try """
        // This file is automatically generated. Do not edit.
        // swiftlint:disable all
        // swiftformat:disable all

        import Foundation
        import XRPC
        import XRPCSupport
        \(generateMainTypes())
        """
    }

    @CodeBlockItemListBuilder
    func generateMainTypes() throws -> CodeBlockItemListSyntax {
        if let main = lexicon.defs["main"] {
            try generateDecls(main, key: "main", static: false)
            try generateMainExtension(main)
        } else {
            try generateAdditionalDecls(static: false)
        }
    }
    
    @CodeBlockItemListBuilder
    func generateDecls(_ definition: Definition, key: String, static isStatic: Bool) throws -> CodeBlockItemListSyntax {
        let prefix = isStatic ? "" : lexicon.swiftTypeNamePrefix
        let suffix = key == "main" ? "" : key.firstLetterCapitalized
        let typeName = "\(prefix)\(suffix)"
        switch definition {
        case .array(let value):
            try generateArrayItemType(value.items, name: typeName, ref: "`\(lexicon.id)#\(key)`")
        case .object(let value):
            try generateObjectType(value, name: typeName, ref: "`\(lexicon.id)#\(key)`")
        case .procedure(let procedure):
            try """


            \(raw: generateDocComment(lines: [
            procedure.description,
            "The procedure definition for `\(lexicon.id)#\(key)`."
            ]))
            \(raw: visibility.rawValue) struct \(raw: typeName): XRPCRequest {
                \(raw: visibility.rawValue) static let name = "\(raw: lexicon.id)"
                \(raw: visibility.rawValue) static let httpMethod = "POST"
                \(generateRequestDecls(procedure.parameters))
                \(generateBodyType(procedure.input, name: "Input", ref: "``\(typeName)``"))
                \(generateBodyType(procedure.output, name: "Output", ref: "``\(typeName)``"))
                \(generateFailureType(procedure.errors, ref: "``\(typeName)``"))
            }
            """
        case .query(let query):
            try """


            \(raw: generateDocComment(lines: [
                query.description,
                "The query definition for `\(lexicon.id)#\(key)`."
            ]))
            \(raw: visibility.rawValue) struct \(raw: typeName): XRPCRequest {
                \(raw: visibility.rawValue) static let name = "\(raw: lexicon.id)"
                \(raw: visibility.rawValue) static let httpMethod = "GET"
                \(generateRequestDecls(query.parameters))
                \(generateBodyType(query.output, name: "Output", ref: "``\(typeName)``"))
                \(generateFailureType(query.errors, ref: "``\(typeName)``"))
            }
            """
        case .record(let value):
            try generateObjectType(value.record, name: typeName, ref: "`\(lexicon.id)#\(key)`", description: value.description)
        case .string(let value):
            generateStringType(value, name: typeName, ref: "`\(lexicon.id)#\(key)`")
        case .subscription(let value):
            """


            \(raw: generateDocComment(lines: [
                value.description,
                "The subscription definition for `\(lexicon.id)#\(key)`.",
                "Not yet supported."
            ]))
            \(raw: visibility.rawValue) enum \(raw: typeName) {}
            """
        case .blob, .boolean, .bytes, .cidLink, .integer, .null, .parameters, .reference, .token, .unknown:
            []
        }
    }

    @CodeBlockItemListBuilder
    func generateArrayItemType(_ property: Definition.Parameters.Property, name: String, ref: String) throws -> CodeBlockItemListSyntax {
        switch property {
        case .string(let value) where value.knownValues?.isEmpty == false:
            generateStringType(value, name: name, ref: ref)
        case .array, .boolean, .integer, .string:
            []
        }
    }

    @CodeBlockItemListBuilder
    func generateArrayItemType(_ property: Definition.Object.Property, name: String, ref: String) throws -> CodeBlockItemListSyntax {
        switch property {
        case .string(let value) where value.knownValues?.isEmpty == false:
            generateStringType(value, name: name, ref: ref)
        case .union(let value):
            try generateUnionType(value, name: name, ref: ref, indirect: false)
        case .array, .blob, .boolean, .bytes, .cidLink, .integer, .reference, .string, .unknown:
            []
        }
    }
    
    @CodeBlockItemListBuilder
    func generateStringType(_ value: Definition.StringValue, name: String, ref: String) -> CodeBlockItemListSyntax {
        """
        

        \(raw: generateDocComment(lines: [
            value.description,
            "The strings definition for \(ref)."
        ]))
        \(raw: visibility.rawValue) struct \(raw: name.firstLetterCapitalized): RawRepresentable, Sendable, Equatable, Codable {
            \(raw: visibility.rawValue) let rawValue: String
            \(raw: visibility.rawValue) init(rawValue: String) {
                self.rawValue = rawValue
            }
            \(generateTokenDecls(value))
        }
        """
    }
    
    @CodeBlockItemListBuilder
    func generateUnionType(_ value: Definition.Union, name: String, ref: String, description: String? = nil, indirect: Bool) throws -> CodeBlockItemListSyntax {
        """
        
        
        \(raw: generateDocComment(lines: [
            description ?? value.description,
            "The union definition for \(ref)."
        ]))
        \(raw: value.closed == true ? "@XRPCClosed" : "@XRPCOpen") @XRPCTag("$type")
        \(raw: visibility.rawValue) \(raw: indirect ? "indirect " : "")enum \(raw: name.firstLetterCapitalized): Sendable {
        """

        let refs = try value.refs.map(requireRef)
        let isUnique = refs.isUnique(by: \.key)
        for ref in refs {
            let isMain = ref.key == "main"
            let tag = isMain ? ref.lexicon.id : "\(ref.lexicon.id)#\(ref.key)"
            let identifier = [
                isUnique && !isMain ? "" : ref.lexicon.swiftIdentifierPrefix,
                isMain ? "" : ref.key
            ].joinedCamelCase()

            """

                @XRPCTag("\(raw: tag)")
                case \(raw: identifier)(\(generateType(ref)))
            """
        }

        """

        }
        """
    }

    func generateDocComment(lines: [String?]) -> String {
        lines
            .compactMap { $0 }
            .map { "/// \($0)" }
            .joined(separator: "\n///\n")
    }

    @CodeBlockItemListBuilder
    func generateMainExtension(_ definition: Definition) throws -> CodeBlockItemListSyntax {
        try """


        extension \(raw: lexicon.swiftTypeNamePrefix) {
            \(generateAdditionalDecls(static: true))
        }
        """
    }

    @CodeBlockItemListBuilder
    func generateAdditionalDecls(static isStatic: Bool) throws -> CodeBlockItemListSyntax {
        for (key, def) in lexicon.defs where key != "main" {
            try generateDecls(def, key: key, static: isStatic)
        }
    }

    struct EvaluatedReference {
        var key: String
        var definition: Definition
        var lexicon: Lexicon
    }

    func evaluateRef(_ value: String) -> EvaluatedReference? {
        let output = value.split(separator: "#", maxSplits: 1, omittingEmptySubsequences: false)
        guard !output.isEmpty else { return nil }
        guard let lexicon = output[0].isEmpty ? lexicon : lexiconsByID["\(output[0])"] else { return nil }
        let key = output.dropFirst().first?.ifNotEmpty.flatMap { "\($0)" } ?? "main"
        guard let definition = lexicon.defs[key] else { return nil }
        return EvaluatedReference(key: key, definition: definition, lexicon: lexicon)
    }

    func requireRef(_ value: String) throws -> EvaluatedReference {
        guard let ref = evaluateRef(value) else {
            throw Failure.referenceNotFound(value)
        }
        return ref
    }

    @CodeBlockItemListBuilder
    func generateTokenDecls(_ value: Definition.StringValue) -> CodeBlockItemListSyntax {
        for knownValue in value.knownValues ?? [] {
            if let ref = evaluateRef(knownValue) {
                """
                
                \(raw: generateDocComment(lines: [
                    ref.definition.description,
                    "The token `\(knownValue)`."
                ]))
                \(raw: visibility.rawValue) static let \(raw: ref.key) = Self(rawValue: "\(raw: knownValue)")
                """
            } else {
                """
                
                \(raw: generateDocComment(lines: [ "The token `\(knownValue)`." ]))
                \(raw: visibility.rawValue) static let \(raw: knownValue.firstLetterLowercased) = Self(rawValue: "\(raw: knownValue)")
                """
            }
        }
    }

    @CodeBlockItemListBuilder
    func generateObjectType(_ value: Definition.Object, name: String, ref: String, description: String? = nil) throws -> CodeBlockItemListSyntax {
        try """


        \(raw: generateDocComment(lines: [
            description ?? value.description,
            "The object definition for \(ref)."
        ]))
        \(raw: visibility.rawValue) struct \(raw: name.firstLetterCapitalized): Sendable, Codable {
            \(generateObjectDecls(value))

        }
        """
    }

    @CodeBlockItemListBuilder
    func generateRequestDecls(_ value: Definition.Parameters?) throws -> CodeBlockItemListSyntax {
        let required = Set(value?.required ?? [])

        for (name, property) in value?.properties ?? [:] {
            let isRequired = required.contains(name)
            let optionalSuffix = isRequired ? "" : "?"
            try """

            \(raw: generateDocComment(lines: [ property.description ]))
            \(raw: visibility.rawValue) var \(raw: name): \(generateType(property, name: name))\(raw: optionalSuffix)
            """

            switch property {
            case .array(let value):
                try generateArrayItemType(value.items, name: name, ref: "``\(name)``")
            case .string(let value) where value.knownValues?.isEmpty == false:
                generateStringType(value, name: name, ref: "``\(name)``")
            case .boolean, .integer, .string:
                []
            }
        }

        try """


        \(raw: visibility.rawValue) init(\(generateRequestInitDecls(value))) {
            \(generateRequestInitBody(value))
        }
        """

        if let properties = value?.properties.ifNotEmpty {
            """


            \(raw: visibility.rawValue) var urlQueryItems: [Foundation.URLQueryItem] {
                var _queryItemsResult = [Foundation.URLQueryItem]()
            """

            for (name, property) in properties {
                let isRequired = required.contains(name)
                switch property {
                case .array(let value):
                    """

                        for value in \(raw: name)\(raw: isRequired ? "" : " ?? []") {
                            _queryItemsResult.append(Foundation.URLQueryItem(name: "\(raw: name)", value: \(generateValueBody(value.items))))
                        }
                    """
                case .boolean, .integer, .string:
                    if isRequired {
                        """

                            _queryItemsResult.append(Foundation.URLQueryItem(name: "\(raw: name)", value: \(generateValueBody(property, identifier: name))))
                        """
                    } else {
                        """

                            if let value = \(raw: name) {
                                _queryItemsResult.append(Foundation.URLQueryItem(name: "\(raw: name)", value: \(generateValueBody(property))))
                            }
                        """
                    }
                }
            }

            """

                return _queryItemsResult
            }
            """
        }
    }

    @CodeBlockItemListBuilder
    func generateValueBody(_ value: Definition.Parameters.Property, identifier: String = "value") -> CodeBlockItemListSyntax {
        switch value {
        case .boolean:
            """
            \(raw: identifier) ? "true" : "false"
            """
        case .array, .integer, .string:
            #"""
            "\(\#(raw: identifier))"
            """#
        }
    }

    @CodeBlockItemListBuilder
    func generateObjectDecls(_ value: Definition.Object) throws -> CodeBlockItemListSyntax {
        let required = Set(value.required ?? [])

        for (name, property) in value.properties {
            let isRequired = required.contains(name)
            let optionalSuffix = isRequired ? "" : "?"
            try """

            \(raw: generateDocComment(lines: [ property.description ]))
            \(raw: visibility.rawValue) var \(raw: name): \(generateType(property, name: name))\(raw: optionalSuffix)
            """

            switch property {
            case .array(let value):
                try generateArrayItemType(value.items, name: name, ref: "``\(name)``")
            case .string(let value) where value.knownValues?.isEmpty == false:
                generateStringType(value, name: name, ref: "``\(name)``")
            case .union(let value):
                try generateUnionType(value, name: name, ref: "``\(name)``", indirect: true)
            case .blob, .boolean, .bytes, .cidLink, .integer, .reference, .string, .unknown:
                []
            }
        }

        try """


        \(raw: visibility.rawValue) init(\(generateObjectInitDecls(value))) {
            \(generateObjectInitBody(value))
        }
        """
    }

    @FunctionParameterListBuilder
    func generateRequestInitDecls(_ value: Definition.Parameters?) throws -> FunctionParameterListSyntax {
        for key in value?.required ?? [] {
            if let property = value?.properties[key] {
                try FunctionParameterSyntax(firstName: .identifier(key), colon: .colonToken(trailingTrivia: .space), type: generateType(property, name: key), trailingComma: key == value?.required?.last ? nil : .commaToken(trailingTrivia: .space))
            }
        }
    }

    @FunctionParameterListBuilder
    func generateObjectInitDecls(_ value: Definition.Object) throws -> FunctionParameterListSyntax {
        for key in value.required ?? [] {
            if let property = value.properties[key] {
                try FunctionParameterSyntax(firstName: .identifier(key), colon: .colonToken(trailingTrivia: .space), type: generateType(property, name: key), trailingComma: key == value.required?.last ? nil : .commaToken(trailingTrivia: .space))
            }
        }
    }

    @CodeBlockItemListBuilder
    func generateRequestInitBody(_ value: Definition.Parameters?) throws -> CodeBlockItemListSyntax {
        for key in value?.required ?? [] {
            """

            self.\(raw: key) = \(raw: key)
            """
        }
    }

    @CodeBlockItemListBuilder
    func generateObjectInitBody(_ value: Definition.Object) throws -> CodeBlockItemListSyntax {
        for key in value.required ?? [] {
            """
            
            self.\(raw: key) = \(raw: key)
            """
        }
    }

    func generateType(_ ref: EvaluatedReference) -> TypeSyntax {
        let key = ref.key
        let lexicon = ref.lexicon
        if key == "main" {
            return "\(raw: lexicon.swiftTypeNamePrefix)"
        } else if lexicon.defs["main"] != nil {
            return "\(raw: lexicon.swiftTypeNamePrefix).\(raw: key.firstLetterCapitalized)"
        } else {
            return "\(raw: lexicon.swiftTypeNamePrefix)\(raw: key.firstLetterCapitalized)"
        }
    }

    func generateType(_ value: Definition.StringValue, name: String) -> TypeSyntax {
        switch value.format {
        case .dateTime?:
            return "XRPC.XRPCDate"
        case .language?:
            return "Foundation.Locale.LanguageCode"
        case .uri?:
            return "Foundation.URL"
        case _ where value.knownValues?.isEmpty == false:
            return "\(raw: name.firstLetterCapitalized)"
        default:
            return "Swift.String"
        }
    }

    func generateType(_ property: Definition.Parameters.Property, name: String) throws -> TypeSyntax {
        switch property {
        case .array(let array):
            return try "[\(raw: generateType(array.items, name: name))]"
        case .boolean:
            return "Swift.Bool"
        case .integer:
            return "Swift.Int"
        case .string(let value):
            return generateType(value, name: name)
        }
    }

    func generateType(_ property: Definition.Object.Property, name: String) throws -> TypeSyntax {
        switch property {
        case .array(let array):
            return try "[\(raw: generateType(array.items, name: name))]"
        case .blob:
            return "XRPC.XRPCBlob"
        case .boolean(_):
            return "Swift.Bool"
        case .cidLink:
            return "XRPC.XRPCLink"
        case .integer:
            return "Swift.Int"
        case .reference(let value):
            return try generateType(requireRef(value.ref))
        case .string(let value):
            return generateType(value, name: name)
        case .union:
            return "\(raw: name.firstLetterCapitalized)"
        case .bytes, .unknown:
            return "XRPC.XRPCUnknown"
        }
    }

    @CodeBlockItemListBuilder
    func generateBodyType(_ value: Definition.Procedure.Body?, name: String, ref: String) throws -> CodeBlockItemListSyntax {
        if let value, value.encoding == "application/json", let schema = value.schema {
            switch schema {
            case .object(let object):
                try generateObjectType(object, name: name, ref: ref, description: value.description)
            case .reference(let reference):
                try """

                \(raw: generateDocComment(lines: [ value.description ]))
                \(raw: visibility.rawValue) typealias \(raw: name) = \(generateType(requireRef(reference.ref)))
                """
            case .union(let union):
                try generateUnionType(union, name: name, ref: ref, description: value.description, indirect: true)
            }
        } else if let value {
            """

            \(raw: generateDocComment(lines: [ value.description ]))
            \(raw: visibility.rawValue) typealias \(raw: name) = Foundation.Data
            """
        }
    }

    @CodeBlockItemListBuilder
    func generateFailureType(_ values: [Definition.Procedure.ErrorValue]?, ref: String) throws -> CodeBlockItemListSyntax {
        if let values = values?.ifNotEmpty {
            """
            \(raw: generateDocComment(lines: [
                "The errors for \(ref)."
            ]))
            \(raw: visibility.rawValue) struct Failure: RawRepresentable, Sendable, Equatable, Codable {
                \(raw: visibility.rawValue) let rawValue: String
                \(raw: visibility.rawValue) init(rawValue: String) {
                    self.rawValue = rawValue
                }
            """

            for value in values {
                """

                    \(raw: generateDocComment(lines: [
                        value.description,
                        "The error `\(value.name)`."
                    ]))
                    \(raw: visibility.rawValue) static let \(raw: value.name.firstLetterLowercased) = Self(rawValue: "\(raw: value.name)")
                """
            }

            """

            }
            """
        }
    }
}
